// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use super::{Identifyer, TurtleDoc, Statement, Literal, Object, Directive,
            Triple};
use std::num::from_str_radix;
use self::ParseResult::{Matched, Failed};
enum ParseResult<T> { Matched(usize, T), Failed, }
struct ParseState {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> ParseResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0us;
    let mut input_iter = input[pos..].chars();
    for m_char in m.chars() {
        let m_char_upper = m_char.to_uppercase();
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap().to_uppercase() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
fn parse_turtleDoc<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<TurtleDoc> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res = parse_statement(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { TurtleDoc{statements: Vec::new(),} })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_statement<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_directive(input, state, pos);
                    match seq_res {
                        Matched(pos, d) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Statement::Directive(d) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_triples(input, state, pos);
                    match seq_res {
                        Matched(pos, t) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ".");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    { Statement::Triple(t) })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_directive<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<Directive> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_prefixID(input, state, pos);
                    match seq_res {
                        Matched(pos, p) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            let (x, y) = p;
                                            Directive::PrefixID(x, y)
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_base(input, state, pos);
                    match seq_res {
                        Matched(pos, b) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Directive::Base(b) })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_prefixID<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<(String, String)> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res = parse_WS(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "@prefix");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let mut repeat_pos = pos;
                                                    let mut repeat_value =
                                                        vec!();
                                                    loop  {
                                                        let pos = repeat_pos;
                                                        let step_res =
                                                            parse_WS(input,
                                                                     state,
                                                                     pos);
                                                        match step_res {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                repeat_pos =
                                                                    newpos;
                                                                repeat_value.push(value);
                                                            }
                                                            Failed => {
                                                                break ;
                                                            }
                                                        }
                                                    }
                                                    if repeat_value.len() >=
                                                           1us {
                                                        Matched(repeat_pos,
                                                                ())
                                                    } else { Failed }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            match parse_PN_PREFIX(input,
                                                                                  state,
                                                                                  pos)
                                                                {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    Matched(newpos,
                                                                            Some(value))
                                                                }
                                                                Failed => {
                                                                    Matched(pos,
                                                                            None)
                                                                }
                                                            };
                                                        match seq_res {
                                                            Matched(pos, p) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        slice_eq(input,
                                                                                 state,
                                                                                 pos,
                                                                                 ":");
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    {
                                                                                        let mut repeat_pos =
                                                                                            pos;
                                                                                        loop 
                                                                                             {
                                                                                            let pos =
                                                                                                repeat_pos;
                                                                                            let step_res =
                                                                                                parse_WS(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match step_res
                                                                                                {
                                                                                                Matched(newpos,
                                                                                                        value)
                                                                                                =>
                                                                                                {
                                                                                                    repeat_pos
                                                                                                        =
                                                                                                        newpos;
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                {
                                                                                                    break
                                                                                                        ;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Matched(repeat_pos,
                                                                                                ())
                                                                                    };
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse_IRIREF(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        l)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            {
                                                                                                                let mut repeat_pos =
                                                                                                                    pos;
                                                                                                                loop 
                                                                                                                     {
                                                                                                                    let pos =
                                                                                                                        repeat_pos;
                                                                                                                    let step_res =
                                                                                                                        parse_WS(input,
                                                                                                                                 state,
                                                                                                                                 pos);
                                                                                                                    match step_res
                                                                                                                        {
                                                                                                                        Matched(newpos,
                                                                                                                                value)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            repeat_pos
                                                                                                                                =
                                                                                                                                newpos;
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            break
                                                                                                                                ;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Matched(repeat_pos,
                                                                                                                        ())
                                                                                                            };
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        slice_eq(input,
                                                                                                                                 state,
                                                                                                                                 pos,
                                                                                                                                 ".");
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    &input[start_pos..pos];
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            (match p
                                                                                                                                                 {
                                                                                                                                                 Some(e)
                                                                                                                                                 =>
                                                                                                                                                 e,
                                                                                                                                                 None
                                                                                                                                                 =>
                                                                                                                                                 "".to_string(),
                                                                                                                                             },
                                                                                                                                             l)
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "PREFIX");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        let mut repeat_value = vec!();
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                parse_WS(input, state, pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                    repeat_value.push(value);
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        if repeat_value.len() >= 1us {
                                            Matched(repeat_pos, ())
                                        } else { Failed }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                match parse_PN_PREFIX(input,
                                                                      state,
                                                                      pos) {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, p) => {
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     ":");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            let mut repeat_pos =
                                                                                pos;
                                                                            loop 
                                                                                 {
                                                                                let pos =
                                                                                    repeat_pos;
                                                                                let step_res =
                                                                                    parse_WS(input,
                                                                                             state,
                                                                                             pos);
                                                                                match step_res
                                                                                    {
                                                                                    Matched(newpos,
                                                                                            value)
                                                                                    =>
                                                                                    {
                                                                                        repeat_pos
                                                                                            =
                                                                                            newpos;
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                }
                                                                            }
                                                                            Matched(repeat_pos,
                                                                                    ())
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_IRIREF(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            l)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let match_str =
                                                                                                &input[start_pos..pos];
                                                                                            Matched(pos,
                                                                                                    {
                                                                                                        (match p
                                                                                                             {
                                                                                                             Some(e)
                                                                                                             =>
                                                                                                             e,
                                                                                                             None
                                                                                                             =>
                                                                                                             "".to_string(),
                                                                                                         },
                                                                                                         l)
                                                                                                    })
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_base<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<String> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "@base");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                parse_WS(input, state, pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        Matched(repeat_pos, ())
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_IRIREF(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let mut repeat_pos =
                                                                    pos;
                                                                loop  {
                                                                    let pos =
                                                                        repeat_pos;
                                                                    let step_res =
                                                                        parse_WS(input,
                                                                                 state,
                                                                                 pos);
                                                                    match step_res
                                                                        {
                                                                        Matched(newpos,
                                                                                value)
                                                                        => {
                                                                            repeat_pos
                                                                                =
                                                                                newpos;
                                                                        }
                                                                        Failed
                                                                        => {
                                                                            break
                                                                                ;
                                                                        }
                                                                    }
                                                                }
                                                                Matched(repeat_pos,
                                                                        ())
                                                            };
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        slice_eq(input,
                                                                                 state,
                                                                                 pos,
                                                                                 ".");
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    &input[start_pos..pos];
                                                                                Matched(pos,
                                                                                        {
                                                                                            i
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "BASE");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let mut repeat_pos = pos;
                                        loop  {
                                            let pos = repeat_pos;
                                            let step_res =
                                                parse_WS(input, state, pos);
                                            match step_res {
                                                Matched(newpos, value) => {
                                                    repeat_pos = newpos;
                                                }
                                                Failed => { break ; }
                                            }
                                        }
                                        Matched(repeat_pos, ())
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_IRIREF(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { i })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_triples<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<Triple> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_subject(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_predicateObjectList(input, state,
                                                              pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        Triple{subject:
                                                                   Identifyer::NoID,
                                                               predicate:
                                                                   Identifyer::NoID,
                                                               object:
                                                                   Identifyer::NoID,}
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res =
                        parse_blankNodePropertyList(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    match parse_predicateObjectList(input,
                                                                    state,
                                                                    pos) {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => { Matched(pos, None) }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        Triple{subject:
                                                                   Identifyer::NoID,
                                                               predicate:
                                                                   Identifyer::NoID,
                                                               object:
                                                                   Identifyer::NoID,}
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_predicateObjectList<'input>(input: &'input str,
                                     state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_verb(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_objectList(input, state, pos);
                        match seq_res {
                            Matched(pos, o) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     ";");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                match {
                                                                          let seq_res =
                                                                              parse_verb(input,
                                                                                         state,
                                                                                         pos);
                                                                          match seq_res
                                                                              {
                                                                              Matched(pos,
                                                                                      _)
                                                                              =>
                                                                              {
                                                                                  parse_objectList(input,
                                                                                                   state,
                                                                                                   pos)
                                                                              }
                                                                              Failed
                                                                              =>
                                                                              Failed,
                                                                          }
                                                                      } {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos, { () })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_objectList<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> ParseResult<Vec<Object>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_object(input, state, pos);
            match seq_res {
                Matched(pos, f) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         ",");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    parse_object(input, state,
                                                                 pos)
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, g) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Vec::new() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_verb<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res = parse_predicate(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => slice_eq(input, state, pos, "a"),
        }
    }
}
fn parse_subject<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_iri(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_BlankNode(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => parse_collection(input, state, pos),
                }
            }
        }
    }
}
fn parse_predicate<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<()> {
    parse_iri(input, state, pos)
}
fn parse_object<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> ParseResult<Object> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_iri(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { Object::Blank })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_BlankNode(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { Object::Blank })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_collection(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            Object::Collection
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_blankNodePropertyList(input,
                                                                            state,
                                                                            pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Object::BlankNodePropertyList
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_literal(input, state,
                                                              pos);
                                            match seq_res {
                                                Matched(pos, l) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    Object::Literal(l)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<Literal> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_RDFLiteral(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            Literal::RDF(match_str.to_string())
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                parse_NumericLiteral(input, state, pos);
                            match seq_res {
                                Matched(pos, i) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { Literal::Number(i) })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res =
                                parse_BooleanLiteral(input, state, pos);
                            match seq_res {
                                Matched(pos, r) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { Literal::Boolean(r) })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_blankNodePropertyList<'input>(input: &'input str,
                                       state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "[");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        parse_predicateObjectList(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "]")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_collection<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "(");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_object(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, ")")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_NumericLiteral<'input>(input: &'input str, state: &mut ParseState,
                                pos: usize) -> ParseResult<f64> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_INTEGER(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_DECIMAL(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_DOUBLE(input, state, pos),
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos,
                                {
                                    from_str_radix::<f64>(match_str,
                                                          10).unwrap()
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_RDFLiteral<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> ParseResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_String(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match {
                                      let choice_res =
                                          parse_LANGTAG(input, state, pos);
                                      match choice_res {
                                          Matched(pos, value) =>
                                          Matched(pos, value),
                                          Failed => {
                                              let seq_res =
                                                  slice_eq(input, state, pos,
                                                           "^^");
                                              match seq_res {
                                                  Matched(pos, _) => {
                                                      parse_iri(input, state,
                                                                pos)
                                                  }
                                                  Failed => Failed,
                                              }
                                          }
                                      }
                                  } {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { () })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_BooleanLiteral<'input>(input: &'input str, state: &mut ParseState,
                                pos: usize) -> ParseResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "true");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { true })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "false");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { false })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_String<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_STRING_LITERAL_QUOTE(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_STRING_LITERAL_SINGLE_QUOTE(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_STRING_LITERAL_LONG_SINGLE_QUOTE(input,
                                                                   state,
                                                                   pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed =>
                            parse_STRING_LITERAL_LONG_QUOTE(input, state,
                                                            pos),
                        }
                    }
                }
            }
        }
    }
}
fn parse_iri<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_IRIREF(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { () })
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_PrefixedName(input, state, pos),
        }
    }
}
fn parse_PrefixedName<'input>(input: &'input str, state: &mut ParseState,
                              pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_PNAME_LN(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_PNAME_NS(input, state, pos),
        }
    }
}
fn parse_BlankNode<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_BLANK_NODE_LABEL(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_ANON(input, state, pos),
        }
    }
}
fn parse_IRIREF<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "<");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let ::std::str::CharRange {
                                                    ch, next } =
                                                input.char_range_at(pos);
                                            match ch {
                                                '<' | '>' | '\"' | '\\' =>
                                                state.mark_failure(pos,
                                                                   "[<>\"\\]"),
                                                _ => Matched(next, ()),
                                            }
                                        } else {
                                            state.mark_failure(pos,
                                                               "[<>\"\\]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, ">");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str[1..match_str.len()
                                                                             -
                                                                             1].to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_PNAME_NS<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res =
                match parse_PN_PREFIX(input, state, pos) {
                    Matched(newpos, value) => { Matched(newpos, Some(value)) }
                    Failed => { Matched(pos, None) }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = slice_eq(input, state, pos, ":");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { () })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_PNAME_LN<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<()> {
    {
        let seq_res = parse_PNAME_NS(input, state, pos);
        match seq_res {
            Matched(pos, _) => { parse_PN_LOCAL(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_BLANK_NODE_LABEL<'input>(input: &'input str, state: &mut ParseState,
                                  pos: usize) -> ParseResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "_:");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_PN_CHARS_U(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '0' ...'9' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[0-9]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[0-9]")
                                    },
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        match {
                                                  let seq_res =
                                                      {
                                                          let mut repeat_pos =
                                                              pos;
                                                          loop  {
                                                              let pos =
                                                                  repeat_pos;
                                                              let step_res =
                                                                  {
                                                                      let choice_res =
                                                                          parse_PN_CHARS(input,
                                                                                         state,
                                                                                         pos);
                                                                      match choice_res
                                                                          {
                                                                          Matched(pos,
                                                                                  value)
                                                                          =>
                                                                          Matched(pos,
                                                                                  value),
                                                                          Failed
                                                                          =>
                                                                          slice_eq(input,
                                                                                   state,
                                                                                   pos,
                                                                                   "."),
                                                                      }
                                                                  };
                                                              match step_res {
                                                                  Matched(newpos,
                                                                          value)
                                                                  => {
                                                                      repeat_pos
                                                                          =
                                                                          newpos;
                                                                  }
                                                                  Failed => {
                                                                      break ;
                                                                  }
                                                              }
                                                          }
                                                          Matched(repeat_pos,
                                                                  ())
                                                      };
                                                  match seq_res {
                                                      Matched(pos, _) => {
                                                          parse_PN_CHARS(input,
                                                                         state,
                                                                         pos)
                                                      }
                                                      Failed => Failed,
                                                  }
                                              } {
                                            Matched(newpos, value) => {
                                                Matched(newpos, Some(value))
                                            }
                                            Failed => { Matched(pos, None) }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos, { () })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_LANGTAG<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "@");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            'a' ...'z' | 'A' ...'Z' =>
                                            Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[a-zA-Z]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[a-zA-Z]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            if repeat_value.len() >= 1us {
                                Matched(repeat_pos, ())
                            } else { Failed }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "-");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        let mut repeat_value =
                                                            vec!();
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                if input.len()
                                                                       > pos {
                                                                    let ::std::str::CharRange {
                                                                            ch,
                                                                            next
                                                                            } =
                                                                        input.char_range_at(pos);
                                                                    match ch {
                                                                        'a'
                                                                        ...'z'
                                                                        | 'A'
                                                                        ...'Z'
                                                                        | '0'
                                                                        ...'9'
                                                                        =>
                                                                        Matched(next,
                                                                                ()),
                                                                        _ =>
                                                                        state.mark_failure(pos,
                                                                                           "[a-zA-Z0-9]"),
                                                                    }
                                                                } else {
                                                                    state.mark_failure(pos,
                                                                                       "[a-zA-Z0-9]")
                                                                };
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                    repeat_value.push(value);
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        if repeat_value.len()
                                                               >= 1us {
                                                            Matched(repeat_pos,
                                                                    ())
                                                        } else { Failed }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_INTEGER<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let seq_res =
            match if input.len() > pos {
                      let ::std::str::CharRange { ch, next } =
                          input.char_range_at(pos);
                      match ch {
                          '+' | '-' => Matched(next, ()),
                          _ => state.mark_failure(pos, "[+-]"),
                      }
                  } else { state.mark_failure(pos, "[+-]") } {
                Matched(newpos, value) => { Matched(newpos, Some(value)) }
                Failed => { Matched(pos, None) }
            };
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    '0' ...'9' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[0-9]"),
                                }
                            } else { state.mark_failure(pos, "[0-9]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1us {
                        Matched(repeat_pos, ())
                    } else { Failed }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_DECIMAL<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let seq_res =
            match if input.len() > pos {
                      let ::std::str::CharRange { ch, next } =
                          input.char_range_at(pos);
                      match ch {
                          '+' | '-' => Matched(next, ()),
                          _ => state.mark_failure(pos, "[+-]"),
                      }
                  } else { state.mark_failure(pos, "[+-]") } {
                Matched(newpos, value) => { Matched(newpos, Some(value)) }
                Failed => { Matched(pos, None) }
            };
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '0' ...'9' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[0-9]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[0-9]")
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, ".");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    if input.len() > pos {
                                                        let ::std::str::CharRange {
                                                                ch, next } =
                                                            input.char_range_at(pos);
                                                        match ch {
                                                            '0' ...'9' =>
                                                            Matched(next, ()),
                                                            _ =>
                                                            state.mark_failure(pos,
                                                                               "[0-9]"),
                                                        }
                                                    } else {
                                                        state.mark_failure(pos,
                                                                           "[0-9]")
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1us {
                                                Matched(repeat_pos, ())
                                            } else { Failed }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_DOUBLE<'input>(input: &'input str, state: &mut ParseState,
                        pos: usize) -> ParseResult<()> {
    {
        let seq_res =
            match if input.len() > pos {
                      let ::std::str::CharRange { ch, next } =
                          input.char_range_at(pos);
                      match ch {
                          '+' | '-' => Matched(next, ()),
                          _ => state.mark_failure(pos, "[+-]"),
                      }
                  } else { state.mark_failure(pos, "[+-]") } {
                Matched(newpos, value) => { Matched(newpos, Some(value)) }
                Failed => { Matched(pos, None) }
            };
        match seq_res {
            Matched(pos, _) => {
                {
                    let choice_res =
                        {
                            let seq_res =
                                {
                                    let mut repeat_pos = pos;
                                    let mut repeat_value = vec!();
                                    loop  {
                                        let pos = repeat_pos;
                                        let step_res =
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '0' ...'9' =>
                                                    Matched(next, ()),
                                                    _ =>
                                                    state.mark_failure(pos,
                                                                       "[0-9]"),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[0-9]")
                                            };
                                        match step_res {
                                            Matched(newpos, value) => {
                                                repeat_pos = newpos;
                                                repeat_value.push(value);
                                            }
                                            Failed => { break ; }
                                        }
                                    }
                                    if repeat_value.len() >= 1us {
                                        Matched(repeat_pos, ())
                                    } else { Failed }
                                };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ".");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        {
                                                            let mut repeat_pos =
                                                                pos;
                                                            loop  {
                                                                let pos =
                                                                    repeat_pos;
                                                                let step_res =
                                                                    if input.len()
                                                                           >
                                                                           pos
                                                                       {
                                                                        let ::std::str::CharRange {
                                                                                ch,
                                                                                next
                                                                                } =
                                                                            input.char_range_at(pos);
                                                                        match ch
                                                                            {
                                                                            '0'
                                                                            ...'9'
                                                                            =>
                                                                            Matched(next,
                                                                                    ()),
                                                                            _
                                                                            =>
                                                                            state.mark_failure(pos,
                                                                                               "[0-9]"),
                                                                        }
                                                                    } else {
                                                                        state.mark_failure(pos,
                                                                                           "[0-9]")
                                                                    };
                                                                match step_res
                                                                    {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        repeat_pos
                                                                            =
                                                                            newpos;
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        break
                                                                            ;
                                                                    }
                                                                }
                                                            }
                                                            Matched(repeat_pos,
                                                                    ())
                                                        };
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            parse_EXPONENT(input,
                                                                           state,
                                                                           pos)
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res =
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, ".");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        let mut repeat_value =
                                                            vec!();
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                if input.len()
                                                                       > pos {
                                                                    let ::std::str::CharRange {
                                                                            ch,
                                                                            next
                                                                            } =
                                                                        input.char_range_at(pos);
                                                                    match ch {
                                                                        '0'
                                                                        ...'9'
                                                                        =>
                                                                        Matched(next,
                                                                                ()),
                                                                        _ =>
                                                                        state.mark_failure(pos,
                                                                                           "[0-9]"),
                                                                    }
                                                                } else {
                                                                    state.mark_failure(pos,
                                                                                       "[0-9]")
                                                                };
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                    repeat_value.push(value);
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        if repeat_value.len()
                                                               >= 1us {
                                                            Matched(repeat_pos,
                                                                    ())
                                                        } else { Failed }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        parse_EXPONENT(input,
                                                                       state,
                                                                       pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    if input.len() > pos {
                                                        let ::std::str::CharRange {
                                                                ch, next } =
                                                            input.char_range_at(pos);
                                                        match ch {
                                                            '0' ...'9' =>
                                                            Matched(next, ()),
                                                            _ =>
                                                            state.mark_failure(pos,
                                                                               "[0-9]"),
                                                        }
                                                    } else {
                                                        state.mark_failure(pos,
                                                                           "[0-9]")
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1us {
                                                Matched(repeat_pos, ())
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            parse_EXPONENT(input, state, pos)
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_EXPONENT<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<()> {
    {
        let seq_res =
            if input.len() > pos {
                let ::std::str::CharRange { ch, next } =
                    input.char_range_at(pos);
                match ch {
                    'e' | 'E' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[eE]"),
                }
            } else { state.mark_failure(pos, "[eE]") };
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        match if input.len() > pos {
                                  let ::std::str::CharRange { ch, next } =
                                      input.char_range_at(pos);
                                  match ch {
                                      '+' | '-' => Matched(next, ()),
                                      _ => state.mark_failure(pos, "[+-]"),
                                  }
                              } else { state.mark_failure(pos, "[+-]") } {
                            Matched(newpos, value) => {
                                Matched(newpos, Some(value))
                            }
                            Failed => { Matched(pos, None) }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let ::std::str::CharRange {
                                                    ch, next } =
                                                input.char_range_at(pos);
                                            match ch {
                                                '0' ...'9' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[0-9]"),
                                            }
                                        } else {
                                            state.mark_failure(pos, "[0-9]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                if repeat_value.len() >= 1us {
                                    Matched(repeat_pos, ())
                                } else { Failed }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_STRING_LITERAL_QUOTE<'input>(input: &'input str,
                                      state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\"");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let choice_res =
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '\u{2200}' | '\u{5c00}' |
                                                    '\u{a000}' | '\u{d000}' =>
                                                    state.mark_failure(pos,
                                                                       "[\u{2200}\u{5c00}\u{a000}\u{d000}]"),
                                                    _ => Matched(next, ()),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[\u{2200}\u{5c00}\u{a000}\u{d000}]")
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_ECHAR(input, state,
                                                                pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_UCHAR(input, state,
                                                                pos),
                                                }
                                            }
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "\"")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_STRING_LITERAL_SINGLE_QUOTE<'input>(input: &'input str,
                                             state: &mut ParseState,
                                             pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\'");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let choice_res =
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '\u{2700}' | '\u{5c00}' |
                                                    '\u{a000}' | '\u{d000}' =>
                                                    state.mark_failure(pos,
                                                                       "[\u{2700}\u{5c00}\u{a000}\u{d000}]"),
                                                    _ => Matched(next, ()),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[\u{2700}\u{5c00}\u{a000}\u{d000}]")
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_ECHAR(input, state,
                                                                pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_UCHAR(input, state,
                                                                pos),
                                                }
                                            }
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "\'")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_STRING_LITERAL_LONG_SINGLE_QUOTE<'input>(input: &'input str,
                                                  state: &mut ParseState,
                                                  pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\'\'\'");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            match {
                                                      let choice_res =
                                                          slice_eq(input,
                                                                   state, pos,
                                                                   "\'");
                                                      match choice_res {
                                                          Matched(pos, value)
                                                          =>
                                                          Matched(pos, value),
                                                          Failed =>
                                                          slice_eq(input,
                                                                   state, pos,
                                                                   "\'\'"),
                                                      }
                                                  } {
                                                Matched(newpos, value) => {
                                                    Matched(newpos,
                                                            Some(value))
                                                }
                                                Failed => {
                                                    Matched(pos, None)
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let choice_res =
                                                        if input.len() > pos {
                                                            let ::std::str::CharRange {
                                                                    ch, next
                                                                    } =
                                                                input.char_range_at(pos);
                                                            match ch {
                                                                '\'' | '\\' =>
                                                                state.mark_failure(pos,
                                                                                   "[\'\\]"),
                                                                _ =>
                                                                Matched(next,
                                                                        ()),
                                                            }
                                                        } else {
                                                            state.mark_failure(pos,
                                                                               "[\'\\]")
                                                        };
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let choice_res =
                                                                parse_ECHAR(input,
                                                                            state,
                                                                            pos);
                                                            match choice_res {
                                                                Matched(pos,
                                                                        value)
                                                                =>
                                                                Matched(pos,
                                                                        value),
                                                                Failed =>
                                                                parse_UCHAR(input,
                                                                            state,
                                                                            pos),
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "\'\'\'")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_STRING_LITERAL_LONG_QUOTE<'input>(input: &'input str,
                                           state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\"\"\"");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            match {
                                                      let choice_res =
                                                          slice_eq(input,
                                                                   state, pos,
                                                                   "\"");
                                                      match choice_res {
                                                          Matched(pos, value)
                                                          =>
                                                          Matched(pos, value),
                                                          Failed =>
                                                          slice_eq(input,
                                                                   state, pos,
                                                                   "\"\""),
                                                      }
                                                  } {
                                                Matched(newpos, value) => {
                                                    Matched(newpos,
                                                            Some(value))
                                                }
                                                Failed => {
                                                    Matched(pos, None)
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let choice_res =
                                                        if input.len() > pos {
                                                            let ::std::str::CharRange {
                                                                    ch, next
                                                                    } =
                                                                input.char_range_at(pos);
                                                            match ch {
                                                                '\"' | '\\' =>
                                                                state.mark_failure(pos,
                                                                                   "[\"\\]"),
                                                                _ =>
                                                                Matched(next,
                                                                        ()),
                                                            }
                                                        } else {
                                                            state.mark_failure(pos,
                                                                               "[\"\\]")
                                                        };
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let choice_res =
                                                                parse_ECHAR(input,
                                                                            state,
                                                                            pos);
                                                            match choice_res {
                                                                Matched(pos,
                                                                        value)
                                                                =>
                                                                Matched(pos,
                                                                        value),
                                                                Failed =>
                                                                parse_UCHAR(input,
                                                                            state,
                                                                            pos),
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "\"\"\"")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_UCHAR<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res =
            {
                let seq_res = slice_eq(input, state, pos, "\\u");
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let seq_res = parse_HEX(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_HEX(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_HEX(input,
                                                                  state, pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            parse_HEX(input,
                                                                      state,
                                                                      pos)
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let seq_res = slice_eq(input, state, pos, "\\U");
                match seq_res {
                    Matched(pos, _) => {
                        {
                            let seq_res = parse_HEX(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_HEX(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_HEX(input,
                                                                  state, pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    parse_HEX(input,
                                                                              state,
                                                                              pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                parse_HEX(input,
                                                                                          state,
                                                                                          pos);
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse_HEX(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse_HEX(input,
                                                                                                                  state,
                                                                                                                  pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            parse_HEX(input,
                                                                                                                      state,
                                                                                                                      pos)
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}
fn parse_ECHAR<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\\");
        match seq_res {
            Matched(pos, _) => {
                if input.len() > pos {
                    let ::std::str::CharRange { ch, next } =
                        input.char_range_at(pos);
                    match ch {
                        't' | 'b' | 'n' | 'r' | 'f' | '\"' | '\'' =>
                        Matched(next, ()),
                        _ => state.mark_failure(pos, "[tbnrf\"\']"),
                    }
                } else { state.mark_failure(pos, "[tbnrf\"\']") }
            }
            Failed => Failed,
        }
    }
}
fn parse_WS<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res =
            if input.len() > pos {
                let ::std::str::CharRange { ch, next } =
                    input.char_range_at(pos);
                match ch {
                    ' ' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[ ]"),
                }
            } else { state.mark_failure(pos, "[ ]") };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    if input.len() > pos {
                        let ::std::str::CharRange { ch, next } =
                            input.char_range_at(pos);
                        match ch {
                            '\t' => Matched(next, ()),
                            _ => state.mark_failure(pos, "[\t]"),
                        }
                    } else { state.mark_failure(pos, "[\t]") };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    '\r' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[\r]"),
                                }
                            } else { state.mark_failure(pos, "[\r]") };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '\n' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[\n]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[\n]")
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_COMMENT(input, state, pos),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_COMMENT<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "#");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    '\n' | '\r' =>
                                    state.mark_failure(pos, "[\n\r]"),
                                    _ => Matched(next, ()),
                                }
                            } else { state.mark_failure(pos, "[\n\r]") };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_ANON<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "[");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res = parse_WS(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "]")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_PN_CHARS_BASE<'input>(input: &'input str, state: &mut ParseState,
                               pos: usize) -> ParseResult<()> {
    {
        let choice_res =
            if input.len() > pos {
                let ::std::str::CharRange { ch, next } =
                    input.char_range_at(pos);
                match ch {
                    'A' ...'Z' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[A-Z]"),
                }
            } else { state.mark_failure(pos, "[A-Z]") };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    if input.len() > pos {
                        let ::std::str::CharRange { ch, next } =
                            input.char_range_at(pos);
                        match ch {
                            'a' ...'z' => Matched(next, ()),
                            _ => state.mark_failure(pos, "[a-z]"),
                        }
                    } else { state.mark_failure(pos, "[a-z]") };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    '\u{c0}' ...'\u{d6}' => Matched(next, ()),
                                    _ =>
                                    state.mark_failure(pos,
                                                       "[\u{c0}-\u{d6}]"),
                                }
                            } else {
                                state.mark_failure(pos, "[\u{c0}-\u{d6}]")
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '\u{d8}' ...'\u{f6}' =>
                                            Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[\u{d8}-\u{f6}]"),
                                        }
                                    } else {
                                        state.mark_failure(pos,
                                                           "[\u{d8}-\u{f6}]")
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '\u{f8}' ...'\u{2ff}' =>
                                                    Matched(next, ()),
                                                    _ =>
                                                    state.mark_failure(pos,
                                                                       "[\u{f8}-\u{2ff}]"),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[\u{f8}-\u{2ff}]")
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    if input.len() > pos {
                                                        let ::std::str::CharRange {
                                                                ch, next } =
                                                            input.char_range_at(pos);
                                                        match ch {
                                                            '\u{370}'
                                                            ...'\u{37d}' =>
                                                            Matched(next, ()),
                                                            _ =>
                                                            state.mark_failure(pos,
                                                                               "[\u{370}-\u{37d}]"),
                                                        }
                                                    } else {
                                                        state.mark_failure(pos,
                                                                           "[\u{370}-\u{37d}]")
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            if input.len() >
                                                                   pos {
                                                                let ::std::str::CharRange {
                                                                        ch,
                                                                        next
                                                                        } =
                                                                    input.char_range_at(pos);
                                                                match ch {
                                                                    '\u{37f}'
                                                                    ...'\u{1fff}'
                                                                    =>
                                                                    Matched(next,
                                                                            ()),
                                                                    _ =>
                                                                    state.mark_failure(pos,
                                                                                       "[\u{37f}-\u{1fff}]"),
                                                                }
                                                            } else {
                                                                state.mark_failure(pos,
                                                                                   "[\u{37f}-\u{1fff}]")
                                                            };
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    if input.len()
                                                                           >
                                                                           pos
                                                                       {
                                                                        let ::std::str::CharRange {
                                                                                ch,
                                                                                next
                                                                                } =
                                                                            input.char_range_at(pos);
                                                                        match ch
                                                                            {
                                                                            '\u{200c}'
                                                                            ...'\u{200d}'
                                                                            =>
                                                                            Matched(next,
                                                                                    ()),
                                                                            _
                                                                            =>
                                                                            state.mark_failure(pos,
                                                                                               "[\u{200c}-\u{200d}]"),
                                                                        }
                                                                    } else {
                                                                        state.mark_failure(pos,
                                                                                           "[\u{200c}-\u{200d}]")
                                                                    };
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    {
                                                                        let choice_res =
                                                                            if input.len()
                                                                                   >
                                                                                   pos
                                                                               {
                                                                                let ::std::str::CharRange {
                                                                                        ch,
                                                                                        next
                                                                                        } =
                                                                                    input.char_range_at(pos);
                                                                                match ch
                                                                                    {
                                                                                    '\u{2070}'
                                                                                    ...'\u{218f}'
                                                                                    =>
                                                                                    Matched(next,
                                                                                            ()),
                                                                                    _
                                                                                    =>
                                                                                    state.mark_failure(pos,
                                                                                                       "[\u{2070}-\u{218f}]"),
                                                                                }
                                                                            } else {
                                                                                state.mark_failure(pos,
                                                                                                   "[\u{2070}-\u{218f}]")
                                                                            };
                                                                        match choice_res
                                                                            {
                                                                            Matched(pos,
                                                                                    value)
                                                                            =>
                                                                            Matched(pos,
                                                                                    value),
                                                                            Failed
                                                                            =>
                                                                            {
                                                                                let choice_res =
                                                                                    if input.len()
                                                                                           >
                                                                                           pos
                                                                                       {
                                                                                        let ::std::str::CharRange {
                                                                                                ch,
                                                                                                next
                                                                                                } =
                                                                                            input.char_range_at(pos);
                                                                                        match ch
                                                                                            {
                                                                                            '\u{2c00}'
                                                                                            ...'\u{2fef}'
                                                                                            =>
                                                                                            Matched(next,
                                                                                                    ()),
                                                                                            _
                                                                                            =>
                                                                                            state.mark_failure(pos,
                                                                                                               "[\u{2c00}-\u{2fef}]"),
                                                                                        }
                                                                                    } else {
                                                                                        state.mark_failure(pos,
                                                                                                           "[\u{2c00}-\u{2fef}]")
                                                                                    };
                                                                                match choice_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            value)
                                                                                    =>
                                                                                    Matched(pos,
                                                                                            value),
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        let choice_res =
                                                                                            if input.len()
                                                                                                   >
                                                                                                   pos
                                                                                               {
                                                                                                let ::std::str::CharRange {
                                                                                                        ch,
                                                                                                        next
                                                                                                        } =
                                                                                                    input.char_range_at(pos);
                                                                                                match ch
                                                                                                    {
                                                                                                    '\u{3001}'
                                                                                                    ...'\u{d7ff}'
                                                                                                    =>
                                                                                                    Matched(next,
                                                                                                            ()),
                                                                                                    _
                                                                                                    =>
                                                                                                    state.mark_failure(pos,
                                                                                                                       "[\u{3001}-\u{d7ff}]"),
                                                                                                }
                                                                                            } else {
                                                                                                state.mark_failure(pos,
                                                                                                                   "[\u{3001}-\u{d7ff}]")
                                                                                            };
                                                                                        match choice_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    value)
                                                                                            =>
                                                                                            Matched(pos,
                                                                                                    value),
                                                                                            Failed
                                                                                            =>
                                                                                            {
                                                                                                let choice_res =
                                                                                                    if input.len()
                                                                                                           >
                                                                                                           pos
                                                                                                       {
                                                                                                        let ::std::str::CharRange {
                                                                                                                ch,
                                                                                                                next
                                                                                                                } =
                                                                                                            input.char_range_at(pos);
                                                                                                        match ch
                                                                                                            {
                                                                                                            '\u{f900}'
                                                                                                            ...'\u{fdcf}'
                                                                                                            =>
                                                                                                            Matched(next,
                                                                                                                    ()),
                                                                                                            _
                                                                                                            =>
                                                                                                            state.mark_failure(pos,
                                                                                                                               "[\u{f900}-\u{fdcf}]"),
                                                                                                        }
                                                                                                    } else {
                                                                                                        state.mark_failure(pos,
                                                                                                                           "[\u{f900}-\u{fdcf}]")
                                                                                                    };
                                                                                                match choice_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            value)
                                                                                                    =>
                                                                                                    Matched(pos,
                                                                                                            value),
                                                                                                    Failed
                                                                                                    =>
                                                                                                    {
                                                                                                        let choice_res =
                                                                                                            if input.len()
                                                                                                                   >
                                                                                                                   pos
                                                                                                               {
                                                                                                                let ::std::str::CharRange {
                                                                                                                        ch,
                                                                                                                        next
                                                                                                                        } =
                                                                                                                    input.char_range_at(pos);
                                                                                                                match ch
                                                                                                                    {
                                                                                                                    '\u{fdf0}'
                                                                                                                    ...'\u{fffd}'
                                                                                                                    =>
                                                                                                                    Matched(next,
                                                                                                                            ()),
                                                                                                                    _
                                                                                                                    =>
                                                                                                                    state.mark_failure(pos,
                                                                                                                                       "[\u{fdf0}-\u{fffd}]"),
                                                                                                                }
                                                                                                            } else {
                                                                                                                state.mark_failure(pos,
                                                                                                                                   "[\u{fdf0}-\u{fffd}]")
                                                                                                            };
                                                                                                        match choice_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    value)
                                                                                                            =>
                                                                                                            Matched(pos,
                                                                                                                    value),
                                                                                                            Failed
                                                                                                            =>
                                                                                                            if input.len()
                                                                                                                   >
                                                                                                                   pos
                                                                                                               {
                                                                                                                let ::std::str::CharRange {
                                                                                                                        ch,
                                                                                                                        next
                                                                                                                        } =
                                                                                                                    input.char_range_at(pos);
                                                                                                                match ch
                                                                                                                    {
                                                                                                                    '\u{1000}'
                                                                                                                    ...'\u{efff}'
                                                                                                                    =>
                                                                                                                    Matched(next,
                                                                                                                            ()),
                                                                                                                    _
                                                                                                                    =>
                                                                                                                    state.mark_failure(pos,
                                                                                                                                       "[\u{1000}-\u{efff}]"),
                                                                                                                }
                                                                                                            } else {
                                                                                                                state.mark_failure(pos,
                                                                                                                                   "[\u{1000}-\u{efff}]")
                                                                                                            },
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_PN_CHARS_U<'input>(input: &'input str, state: &mut ParseState,
                            pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_PN_CHARS_BASE(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => slice_eq(input, state, pos, "_"),
        }
    }
}
fn parse_PN_CHARS<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<()> {
    {
        let choice_res = parse_PN_CHARS_U(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "-");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            if input.len() > pos {
                                let ::std::str::CharRange { ch, next } =
                                    input.char_range_at(pos);
                                match ch {
                                    '0' ...'9' => Matched(next, ()),
                                    _ => state.mark_failure(pos, "[0-9]"),
                                }
                            } else { state.mark_failure(pos, "[0-9]") };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    if input.len() > pos {
                                        let ::std::str::CharRange { ch, next
                                                } = input.char_range_at(pos);
                                        match ch {
                                            '\u{b7}' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos,
                                                               "[\u{b7}]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[\u{b7}]")
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '\u{300}' ...'\u{36f}' =>
                                                    Matched(next, ()),
                                                    _ =>
                                                    state.mark_failure(pos,
                                                                       "[\u{300}-\u{36f}]"),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[\u{300}-\u{36f}]")
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            if input.len() > pos {
                                                let ::std::str::CharRange {
                                                        ch, next } =
                                                    input.char_range_at(pos);
                                                match ch {
                                                    '\u{203f}' ...'\u{2040}'
                                                    => Matched(next, ()),
                                                    _ =>
                                                    state.mark_failure(pos,
                                                                       "[\u{203f}-\u{2040}]"),
                                                }
                                            } else {
                                                state.mark_failure(pos,
                                                                   "[\u{203f}-\u{2040}]")
                                            },
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_PN_PREFIX<'input>(input: &'input str, state: &mut ParseState,
                           pos: usize) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_PN_CHARS_BASE(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let choice_res =
                                                parse_PN_CHARS(input, state,
                                                               pos);
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed =>
                                                slice_eq(input, state, pos,
                                                         "."),
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { match_str.to_string() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_PN_LOCAL<'input>(input: &'input str, state: &mut ParseState,
                          pos: usize) -> ParseResult<()> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_PN_CHARS_U(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = slice_eq(input, state, pos, ":");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        if input.len() > pos {
                                            let ::std::str::CharRange {
                                                    ch, next } =
                                                input.char_range_at(pos);
                                            match ch {
                                                '0' ...'9' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[0-9]"),
                                            }
                                        } else {
                                            state.mark_failure(pos, "[0-9]")
                                        };
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_PLX(input, state, pos),
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match {
                                      let seq_res =
                                          {
                                              let mut repeat_pos = pos;
                                              loop  {
                                                  let pos = repeat_pos;
                                                  let step_res =
                                                      {
                                                          let choice_res =
                                                              parse_PN_CHARS(input,
                                                                             state,
                                                                             pos);
                                                          match choice_res {
                                                              Matched(pos,
                                                                      value)
                                                              =>
                                                              Matched(pos,
                                                                      value),
                                                              Failed => {
                                                                  let choice_res =
                                                                      slice_eq(input,
                                                                               state,
                                                                               pos,
                                                                               ".");
                                                                  match choice_res
                                                                      {
                                                                      Matched(pos,
                                                                              value)
                                                                      =>
                                                                      Matched(pos,
                                                                              value),
                                                                      Failed
                                                                      => {
                                                                          let choice_res =
                                                                              slice_eq(input,
                                                                                       state,
                                                                                       pos,
                                                                                       ":");
                                                                          match choice_res
                                                                              {
                                                                              Matched(pos,
                                                                                      value)
                                                                              =>
                                                                              Matched(pos,
                                                                                      value),
                                                                              Failed
                                                                              =>
                                                                              parse_PLX(input,
                                                                                        state,
                                                                                        pos),
                                                                          }
                                                                      }
                                                                  }
                                                              }
                                                          }
                                                      };
                                                  match step_res {
                                                      Matched(newpos, value)
                                                      => {
                                                          repeat_pos = newpos;
                                                      }
                                                      Failed => { break ; }
                                                  }
                                              }
                                              Matched(repeat_pos, ())
                                          };
                                      match seq_res {
                                          Matched(pos, _) => {
                                              {
                                                  let choice_res =
                                                      parse_PN_CHARS(input,
                                                                     state,
                                                                     pos);
                                                  match choice_res {
                                                      Matched(pos, value) =>
                                                      Matched(pos, value),
                                                      Failed => {
                                                          let choice_res =
                                                              slice_eq(input,
                                                                       state,
                                                                       pos,
                                                                       ":");
                                                          match choice_res {
                                                              Matched(pos,
                                                                      value)
                                                              =>
                                                              Matched(pos,
                                                                      value),
                                                              Failed =>
                                                              parse_PLX(input,
                                                                        state,
                                                                        pos),
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                          Failed => Failed,
                                      }
                                  } {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { () })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_PLX<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res = parse_PERCENT(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_PN_LOCAL_ESC(input, state, pos),
        }
    }
}
fn parse_PERCENT<'input>(input: &'input str, state: &mut ParseState,
                         pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "%");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res = parse_HEX(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => { parse_HEX(input, state, pos) }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_HEX<'input>(input: &'input str, state: &mut ParseState, pos: usize)
 -> ParseResult<()> {
    {
        let choice_res =
            if input.len() > pos {
                let ::std::str::CharRange { ch, next } =
                    input.char_range_at(pos);
                match ch {
                    '0' ...'9' => Matched(next, ()),
                    _ => state.mark_failure(pos, "[0-9]"),
                }
            } else { state.mark_failure(pos, "[0-9]") };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    if input.len() > pos {
                        let ::std::str::CharRange { ch, next } =
                            input.char_range_at(pos);
                        match ch {
                            'A' ...'F' => Matched(next, ()),
                            _ => state.mark_failure(pos, "[A-F]"),
                        }
                    } else { state.mark_failure(pos, "[A-F]") };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed =>
                    if input.len() > pos {
                        let ::std::str::CharRange { ch, next } =
                            input.char_range_at(pos);
                        match ch {
                            'a' ...'f' => Matched(next, ()),
                            _ => state.mark_failure(pos, "[a-f]"),
                        }
                    } else { state.mark_failure(pos, "[a-f]") },
                }
            }
        }
    }
}
fn parse_PN_LOCAL_ESC<'input>(input: &'input str, state: &mut ParseState,
                              pos: usize) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "\\");
        match seq_res {
            Matched(pos, _) => {
                {
                    let choice_res = slice_eq(input, state, pos, "_");
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = slice_eq(input, state, pos, "~");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, ".");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let choice_res =
                                                slice_eq(input, state, pos,
                                                         "-");
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed => {
                                                    let choice_res =
                                                        slice_eq(input, state,
                                                                 pos, "!");
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed => {
                                                            let choice_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "$");
                                                            match choice_res {
                                                                Matched(pos,
                                                                        value)
                                                                =>
                                                                Matched(pos,
                                                                        value),
                                                                Failed => {
                                                                    let choice_res =
                                                                        slice_eq(input,
                                                                                 state,
                                                                                 pos,
                                                                                 "&");
                                                                    match choice_res
                                                                        {
                                                                        Matched(pos,
                                                                                value)
                                                                        =>
                                                                        Matched(pos,
                                                                                value),
                                                                        Failed
                                                                        => {
                                                                            let choice_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         "\'");
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    let choice_res =
                                                                                        slice_eq(input,
                                                                                                 state,
                                                                                                 pos,
                                                                                                 "(");
                                                                                    match choice_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                value)
                                                                                        =>
                                                                                        Matched(pos,
                                                                                                value),
                                                                                        Failed
                                                                                        =>
                                                                                        {
                                                                                            let choice_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         ")");
                                                                                            match choice_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        value)
                                                                                                =>
                                                                                                Matched(pos,
                                                                                                        value),
                                                                                                Failed
                                                                                                =>
                                                                                                {
                                                                                                    let choice_res =
                                                                                                        slice_eq(input,
                                                                                                                 state,
                                                                                                                 pos,
                                                                                                                 "*");
                                                                                                    match choice_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                value)
                                                                                                        =>
                                                                                                        Matched(pos,
                                                                                                                value),
                                                                                                        Failed
                                                                                                        =>
                                                                                                        {
                                                                                                            let choice_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         "+");
                                                                                                            match choice_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        value)
                                                                                                                =>
                                                                                                                Matched(pos,
                                                                                                                        value),
                                                                                                                Failed
                                                                                                                =>
                                                                                                                {
                                                                                                                    let choice_res =
                                                                                                                        slice_eq(input,
                                                                                                                                 state,
                                                                                                                                 pos,
                                                                                                                                 ",");
                                                                                                                    match choice_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                value)
                                                                                                                        =>
                                                                                                                        Matched(pos,
                                                                                                                                value),
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            let choice_res =
                                                                                                                                slice_eq(input,
                                                                                                                                         state,
                                                                                                                                         pos,
                                                                                                                                         ";");
                                                                                                                            match choice_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        value)
                                                                                                                                =>
                                                                                                                                Matched(pos,
                                                                                                                                        value),
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    let choice_res =
                                                                                                                                        slice_eq(input,
                                                                                                                                                 state,
                                                                                                                                                 pos,
                                                                                                                                                 "=");
                                                                                                                                    match choice_res
                                                                                                                                        {
                                                                                                                                        Matched(pos,
                                                                                                                                                value)
                                                                                                                                        =>
                                                                                                                                        Matched(pos,
                                                                                                                                                value),
                                                                                                                                        Failed
                                                                                                                                        =>
                                                                                                                                        {
                                                                                                                                            let choice_res =
                                                                                                                                                slice_eq(input,
                                                                                                                                                         state,
                                                                                                                                                         pos,
                                                                                                                                                         "/");
                                                                                                                                            match choice_res
                                                                                                                                                {
                                                                                                                                                Matched(pos,
                                                                                                                                                        value)
                                                                                                                                                =>
                                                                                                                                                Matched(pos,
                                                                                                                                                        value),
                                                                                                                                                Failed
                                                                                                                                                =>
                                                                                                                                                {
                                                                                                                                                    let choice_res =
                                                                                                                                                        slice_eq(input,
                                                                                                                                                                 state,
                                                                                                                                                                 pos,
                                                                                                                                                                 "?");
                                                                                                                                                    match choice_res
                                                                                                                                                        {
                                                                                                                                                        Matched(pos,
                                                                                                                                                                value)
                                                                                                                                                        =>
                                                                                                                                                        Matched(pos,
                                                                                                                                                                value),
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            let choice_res =
                                                                                                                                                                slice_eq(input,
                                                                                                                                                                         state,
                                                                                                                                                                         pos,
                                                                                                                                                                         "#");
                                                                                                                                                            match choice_res
                                                                                                                                                                {
                                                                                                                                                                Matched(pos,
                                                                                                                                                                        value)
                                                                                                                                                                =>
                                                                                                                                                                Matched(pos,
                                                                                                                                                                        value),
                                                                                                                                                                Failed
                                                                                                                                                                =>
                                                                                                                                                                {
                                                                                                                                                                    let choice_res =
                                                                                                                                                                        slice_eq(input,
                                                                                                                                                                                 state,
                                                                                                                                                                                 pos,
                                                                                                                                                                                 "@");
                                                                                                                                                                    match choice_res
                                                                                                                                                                        {
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                value)
                                                                                                                                                                        =>
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                value),
                                                                                                                                                                        Failed
                                                                                                                                                                        =>
                                                                                                                                                                        slice_eq(input,
                                                                                                                                                                                 state,
                                                                                                                                                                                 pos,
                                                                                                                                                                                 "%"),
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}
pub fn turtleDoc<'input>(input: &'input str) -> Result<TurtleDoc, String> {
    let mut state = ParseState::new();
    match parse_turtleDoc(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
pub fn directive<'input>(input: &'input str) -> Result<Directive, String> {
    let mut state = ParseState::new();
    match parse_directive(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
pub fn prefixID<'input>(input: &'input str)
 -> Result<(String, String), String> {
    let mut state = ParseState::new();
    match parse_prefixID(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
pub fn base<'input>(input: &'input str) -> Result<String, String> {
    let mut state = ParseState::new();
    match parse_base(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
pub fn triples<'input>(input: &'input str) -> Result<Triple, String> {
    let mut state = ParseState::new();
    match parse_triples(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
pub fn IRIREF<'input>(input: &'input str) -> Result<String, String> {
    let mut state = ParseState::new();
    match parse_IRIREF(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(format!("Error at Line {}:{}: Expected {:?}" , line , col , state .
                expected))
}
